"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const react_spring_1 = require("react-spring");
const KeyboardArrowLeft_1 = __importDefault(require("@material-ui/icons/KeyboardArrowLeft"));
const KeyboardArrowRight_1 = __importDefault(require("@material-ui/icons/KeyboardArrowRight"));
const initialState = {
    galleryPosition: 0,
    galleryWidth: 0,
    useableWidth: 0,
    elementsShown: 0,
    excessSpace: 0,
    paddingComponentWidth: 20
};
function reducer(state, action) {
    switch (action.type) {
        case "movePrev": {
            if (state.galleryPosition > 0) {
                return Object.assign(Object.assign({}, state), { galleryPosition: state.galleryPosition - 1 });
            }
            else if (action.payload.onReachStart !== undefined) {
                action.payload.onReachStart(state);
            }
            return state;
        }
        case "moveNext": {
            if (state.galleryPosition < action.payload.elementCount - state.elementsShown) {
                return Object.assign(Object.assign({}, state), { galleryPosition: state.galleryPosition + 1 });
            }
            else if (action.payload.onReachEnd !== undefined) {
                action.payload.onReachEnd(state);
            }
            return state;
        }
        case "setGalleryWidth": {
            const useableWidth = action.payload.galleryWidth - 2 * action.payload.fadeDistance;
            const elementsShown = Math.floor(useableWidth / (action.payload.elementWidth + action.payload.minPadding));
            const excessSpace = useableWidth - action.payload.elementWidth * elementsShown;
            const totalComponentPadding = elementsShown < 2 ? 0 : excessSpace / (elementsShown - 1);
            return Object.assign(Object.assign({}, state), { galleryWidth: action.payload.galleryWidth, useableWidth,
                elementsShown,
                excessSpace, paddingComponentWidth: totalComponentPadding });
        }
        default:
            throw new Error("Invalid action type");
    }
}
const HorizontalGallery = (props) => {
    const { tiles, elementWidth, onReachEnd, onReachStart } = props;
    const fadeDistance = props.fadeDistance || 100;
    const minPadding = props.minPadding || 20;
    const [galleryTrack] = react_1.useState(react_1.default.createRef());
    const [state, dispatch] = react_1.useReducer(reducer, initialState);
    react_1.useLayoutEffect(() => {
        if (galleryTrack !== undefined) {
            const element = galleryTrack.current;
            if (element !== null) {
                const updateSize = () => dispatch({
                    type: "setGalleryWidth",
                    payload: {
                        galleryWidth: element.getBoundingClientRect().width,
                        fadeDistance,
                        elementWidth,
                        minPadding
                    }
                });
                // This is an instantaneous delay, allowing the page to render a vertical scroll bar if needed,
                // and then take that into account when settings size
                setTimeout(() => updateSize(), 1000);
                window.addEventListener("resize", updateSize);
                return () => window.removeEventListener("resize", updateSize);
            }
        }
    }, [elementWidth, fadeDistance, galleryTrack, minPadding]);
    const trackProps = react_spring_1.useSpring({
        to: {
            transform: `translate(${fadeDistance - (elementWidth + state.paddingComponentWidth) * state.galleryPosition}px)`
        }
    });
    const paddingProps = react_spring_1.useSpring({
        to: {
            paddingRight: state.paddingComponentWidth
        }
    });
    return (react_1.default.createElement("div", { style: { display: "flex", position: "relative" } },
        react_1.default.createElement("div", { style: { display: "flex", width: "100%", overflow: "hidden" }, ref: galleryTrack },
            react_1.default.createElement(react_spring_1.animated.div, { style: Object.assign({ display: "flex" }, trackProps) }, tiles.map((tile, index) => (react_1.default.createElement(react_spring_1.animated.div, { key: index, style: Object.assign(Object.assign({}, paddingProps), { width: elementWidth, overflow: "hidden", visibility: index > state.galleryPosition - 2 && index < state.galleryPosition + state.elementsShown + 1 ? "visible" : "hidden" }) }, tile))))),
        react_1.default.createElement("div", { style: {
                position: "absolute",
                display: "flex",
                justifyContent: "flex-start",
                alignItems: "center",
                left: "0",
                height: "100%",
                width: fadeDistance,
                background: "linear-gradient(to right, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0))"
            } },
            react_1.default.createElement(KeyboardArrowLeft_1.default, { style: { transform: "translate(-110%)", opacity: state.galleryPosition > 0 ? 1 : 0.2 }, onClick: () => dispatch({ type: "movePrev", payload: { onReachStart } }) })),
        react_1.default.createElement("div", { style: {
                position: "absolute",
                display: "flex",
                justifyContent: "flex-end",
                alignItems: "center",
                right: "0",
                height: "100%",
                width: fadeDistance,
                background: "linear-gradient(to left, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0))"
            } },
            react_1.default.createElement(KeyboardArrowRight_1.default, { style: { transform: "translate(110%)", opacity: state.galleryPosition < tiles.length - state.elementsShown ? 1 : 0.2 }, onClick: () => dispatch({
                    type: "moveNext",
                    payload: { elementCount: tiles.length, onReachEnd }
                }) }))));
};
exports.default = HorizontalGallery;
//# sourceMappingURL=index.js.map